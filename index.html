<!DOCTYPE html>
<html>
  <head>
    <title>Functional JSON with Java 8</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Functional JSON with Java 8

---

# Agenda

1. Functions: The quickest recap ever
1. Algebraic Data Types or Coproducts where art thou
1. Immutable-JSON
1. Extractors
1. Codecs
1. Why would you even want to do this?
???

#Agenda Notes

---

# Functions

Java defines a function as a Single Abstract Method interface or SAM interface.

---

# Functions
This is the simplest form of function there is. No inputs, return nothing.

```java
public interface Runnable {
  void run() {}
}
```
The only way this can be useful is to apply side effects.

## Example

```java
 Runnable runner = () -> {
   System.out.println("Hello World");
 }
```
---

# Functions

```java
public interface Supplier<A> {
  A get();
}
```

Produces a value `A`. Can also be called `Function0`. Meaning it takes no arguments, but produces some value A.
This can be seen as a generalization of the `Runnable` interface except that it returns a value.

## Example

```java
 Supplier<Integer> getFive = () -> 5
```

---

# Functions

```java
public interface Function<A, B> {
  B apply(A input);
}
```

Produces a value `B` from an input of `A`.

## Example

```java
Function<String, Integer> toInt = (a) -> Integer.parseInt(a)
```
---

# Functions

Did anyone spot a problem with the this function?

```java
Function<String, Integer> toInt = (String a) -> Integer.parseInt(a)
```

* Not all strings can be converted to Ints.
* This means that we will get a `NumberFormatException` if we for instance pass `"five"` to this function.

---

# Optional

We can fix the problem in the previous function by using the `java.util.Optional` type.

```java
Function<String, Optional<Integer>> toInt = (a) -> {
  try {
    return Optional.of(Integer.parseInt(a));
  } catch (NumberFormatException e) {
    return Optional.empty();
  }
}
```

---

# Pure Functions

A function should ONLY be dependant on its `inputs`.
Calling a function with the same parameters should result in the same result **every time** it is called.
This means that a function cannot perform any side effects.

## Example

```java
Logger logger = ...;

Function<String, Optional<Integer>> safeToInt = (a) -> {
  try {
    return Optional.of(Integer.parseInt(a));
  } catch (NumberFormatException e) {
    logger.info("Failed parsing " + a, e);
    return Optional.empty();
  }
}
```

How many people think this is pure?

---
# Higher Order Functions ( HOF )

A HOF is a function that takes a function as an argument, or returns a function.

## Example

```java
public static <A,B> List<B> map(List<A> list, Function<A, B> f) {
  List<B> newList = new ArrayList<>();
  for (A item : list) {
    newList.add(f.apply(item));
  }
  return newList;
}
```
### Usage
```java
List<Integer> ints = map(Arrays.asList("1", "2", "3", "4"), toInt);
```

---
class: center,middle
# Questions so far?

---

# Algebraic Data Types ( ADT )

This is just another Patternâ„¢ like any GoF pattern, but embraces functions.

These types are often also called `Sum-types` or `Coproducts`.

We typically use this when we want to express data that are closely related and should only exist version of.

Examples of typical ADTs:

- Option
--

- Either
--

- Enumerations
--

- Iteratees
--

- JSON


---
# Example of a simple ADT

## haskell
```haskell
data Option a = None | Some a
```

## Scala
```scala
sealed trait Option[A]

case object None extend Option[Nothing]

case class Some[A](value: A) extends Option[A]
```
---

# ADT in Java
```java
public abstract class Option<A> {
  private Option<A>() {
  }

  public static <A> Option<A> some(A value) { return new Some<>(value); }
  public static <A> Option<A> none() { return new None(); }

  public abstract <B> B fold(Function<A, B> someF, Supplier<B> noneF);

  private static class Some<A> extends Option<A> {
    private final A value;
    public Some(A value) {
      this.value = value;
    }

    public <B> B fold(Function<A, B> someF, Supplier<B> noneF) {
      return someF.apply(value);
    }
  }

  private static class None extends Option<Object> {
    public <B> B fold( Function<A, B> someF, Supplier<B> noneF) {
      return noneF.get();
    }
  }
}
```
---

# Fold
> In functional programming, fold (also termed reduce, accumulate, aggregate, compress, or inject) refers to a family
of higher-order functions that analyze a recursive data structure and through use of a given combining operation,
recombine the results of recursively processing its constituent parts, building up a return value.

Wikipedia

---

# Fold
```java
  public abstract <B> B fold(Function<A, B> someF, Supplier<B> noneF);
```

Operations on `Option`

- getOrElse
--

- map
--

- flatMap
--

- get
--

- getOrElseThrow


???

Having fold in mind, lets take a look at Option.fold
We can implement most operations of Option using this fold method.

Lets have a look for how that would work.

---

# Operations implemented using fold

```java
public A getOrElse(Supplier<A> noneF) {
  return fold(a -> a, noneF);
}
```

```java
public <B> Option<B> map(Function<A, B> f) {
  return fold(a -> Option.some(f.apply(a), Option::none);
}
```

```java
public <B> Option<B> flatMap(Function<A, Option<B>> f) {
  return fold(f, Option::none);
}
```

---

# Operations implemented using fold

```java
public A get() {
  return fold(a -> a, () -> throw new NoSuchElementException("Get on None"));
}
```

```java
public A getOrElseThrow(Supplier<Throwable> noneF) {
  return fold(a -> a, () -> throw noneF.get());
}
```

???

For the astute viewers we know that the getElseOrThrow method cannot be implemented like this, because of Checked Exceptions. There are ways to get around that, but we dont have time to look at this now.
We can also implement map in terms of flatMap and get in terms of getOrElseThrow.

---
class: center, middle
# Immutable JSON


???

Immutable JSON started because I was tired of all mutable JSON libraries out there, and I wanted to see if it was possible
to write a library like [Argonaut](http://argonaut.io) or [Circe](http://circe.io) in Java.


In immutable-json, I have encoded the JSON AST using the ADT pattern.

---

#JSON ADT

```java
public abstract class Json {
  //constructors


  //types
  public static abstract class JValue implements Serializable {
      public abstract <X> X fold(Function<JString, X> fString,
                                 Function<JBoolean, X> fBoolean,
                                 Function<JNumber, X> fNumber,
                                 Function<JObject, X> fObject,
                                 Function<JArray, X> fArray,
                                 Supplier<X> fNull);
  }
  public static final class JString extends JValue {}
  public static final class JBoolean extends JValue {}
  public static final class JNull extends JValue {}
  public static final class JNumber extends JValue {}
  public static final class JArray extends JValue implements Iterable<JValue> {}
  public static final class JObject extends JValue implements
    Iterable<Map.Entry<String, JValue>> {}
}

```

---
class: center, middle
# Lets look at some code

---
# DecodeJson

```java
@FunctionalInterface
public interface DecodeJson<A> {
    DecodeResult<A> fromJson(Json.JValue value);

    default <B> DecodeJson<B> map(Function<A, B> f) {
        return (json) -> this.fromJson(json).map(f);
    }

    default <B> DecodeJson<B> flatMap(Function<A, DecodeJson<B>> f) {
        return value -> {
            DecodeResult<A> result = this.fromJson(value);
            return result.flatMap(a -> f.apply(a).fromJson(value));
        };
    }
}
```


---
# EncodeJson
```java
@FunctionalInterface
public interface EncodeJson<A> {
    Option<Json.JValue> toJson(A value);

    default <B> EncodeJson<B> contramap(Function<B, A> f) {
        return value -> this.toJson(f.apply(value));
    }
}
```

---
# Extractor


```java
@FunctionalInterface
public interface Extractor<A> extends Function<Json.JObject, DecodeResult<A>> {

    default DecodeJson<A> decoder() {
        return (json) -> this.apply(json.asJsonObjectOrEmpty());
    }
}
```

---

```java
public abstract class TypedField<A> {
    public final String name;
    public final DecodeJson<A> decoder;

    private TypedField(String name, DecodeJson<A> decoder) {
        this.name = name;
        this.decoder = decoder;
    }
    //Combinators (map, flatMap, narrow, default value etc)

    public static TypedField<String> TString(String name) {
        return typedFieldOf(name, Codecs.StringCodec, Option.none());
    }
    public static TypedField<Integer> TInt(String name) {
        return typedFieldOf(name, Codecs.intCodec, Option.none());
    }
    public static TypedField<Double> TDouble(String name) {
        return typedFieldOf(name, Codecs.doubleCodec, Option.none());
    }
    public static TypedField<Long> TLong(String name) {
        return typedFieldOf(name, Codecs.longCodec, Option.none());
    }
    public static TypedField<Boolean> TBoolean(String name) {
        return typedFieldOf(name, Codecs.booleanCodec, Option.none());
    }
    public static TJArrayField TJArray(String name) {
        return new TJArrayField(name);
    }
    public static TJObjectField TJObject(String name) {
        return new TJObjectField(name);
    }
    //internal implementation classes and factory method
}
```


???

This represents a field name in a json object and a corresponding way of decoding that type from a json value.
Simplified a bit of course to fit on a slide.


---
# Extractors

```java
public static <TT, A, B, C> Extractor<TT> extract3(
            TypedField<A> f1,
            TypedField<B> f2,
            TypedField<C> f3,
            Function3<A, B, C, TT> func) {

    return (object) -> {
        DecodeResult<A> oa = DecodeResult.decode(object, f1.name, f1.decoder);
        DecodeResult<B> ob = DecodeResult.decode(object, f2.name, f2.decoder);
        DecodeResult<C> oc = DecodeResult.decode(object, f3.name, f3.decoder);
        return oa.flatMap(a ->
                ob.flatMap(b ->
                        oc.flatMap(c ->
                                DecodeResult.ok(func.apply(a, b, c)
                                )
                        )
                )
        );
    };
}
```


---
class: center, middle, white
background-color: black

<h1 style="color: white; font-size: 1000%;">DEMO</h1>

---
#Isomorphism

--
>>> In mathematics, an isomorphism is a homomorphism or morphism (i.e. a mathematical mapping) that admits an inverse.

Wikipedia

---
background-color: black
background-image: url(images/wat.jpg)

---
# Java Encoding of an Isomorphism

```java
public interface Iso<A, B> {
    A reverseGet(B b);
    B get(A a);

    static <A> Iso<A, A> identity() {
        return new IdIso<>();
    }
}

```

---
# Example

```java
public class Person {
    public final String name;
    public final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

   //equals, hashcode and toString
}
```

---
# Person Iso implementation

```java
public enum PersonIso implements Iso<Person, Tuple2<String, Integer>> {
    INSTANCE;

    @Override
    public Person reverseGet(Tuple2<String, Integer> t) {
        return new Person(t._1, t._2);
    }

    @Override
    public Tuple2<String, Integer> get(Person t) {
        return new Tuple2<>(t.name, t.age);
    }
}
```


---

# Codecs


```java
public interface JsonCodec<A> extends EncodeJson<A>, DecodeJson<A> {
    default <B> JsonCodec<B> xmap(Function<A, B> f, Function<B, A> g) {
        return JsonCodec.lift(
          value -> fromJson(value).map(f),
          value -> toJson(g.apply(value))
        );
    }
    default <B> JsonCodec<B> narrow(Function<A, Try<B>> f, Function<B, A> g) {
        return JsonCodec.lift(tryMap(f), value -> toJson(g.apply(value)));
    }
    default <B> JsonCodec<B> tryNarrow(Function<A, B> f, Function<B, A> g) {
        return narrow(a -> Try.of(() -> f.apply(a)), g);
    }
    default <B> JsonCodec<B> tryNarrowBoth(Function<A, B> f, Function<B, A> g) {
        return narrowBoth(
          a -> Try.of(() -> f.apply(a)),
          b -> Try.of(() -> g.apply(b))
        );
    }
    static <A> JsonCodec<A> lift(DecodeJson<A> decoder, EncodeJson<A> encoder) {
        return new DefaultJsonCodec<>(decoder, encoder);
    }
}
```
---
# Codecs

```java
public static <TT, A, B> Function2<String,String, JsonCodec<TT>> codec2(
  Iso<TT, Tuple2<A, B>> iso,
  JsonCodec<A> c1,
  JsonCodec<B> c2) {
    return (n1,n2) -> new JsonCodec<TT>() {
        @Override
        public Option<Json.JValue> toJson(TT value) {
            Tuple2<A, B> tuple = iso.get(value);
            return c1.toJson(tuple._1).
              flatMap(j1 -> c2.toJson(tuple._2).
                flatMap(j2 ->
                Option.of(Json.jObject(Json.entry(n1, j1),Json.entry(n2, j2)))));
        }

        @Override
        public DecodeResult<TT> fromJson(Json.JValue value) {
            Json.JObject object = value.asJsonObjectOrEmpty();

            DecodeResult<A> oa = decode(object, n1, c1);
            DecodeResult<B> ob = decode(object, n2, c2);
            return oa.flatMap(a ->
              ob.flatMap(b ->
                DecodeResult.ok(iso.reverseGet(new Tuple2<>(a,b)))));
        }
    };
}

```
---
# Usage
```java
JsonCodec<Person> personCodec = Codecs.codec2(
  PersonIso.INSTANCE,
  Codecs.StringCodec,
  Codecs.IntCodec).
  apply("name", "age");
```

--
```java
JsonCodec<Person> personCodec = Codecs.codec2(
  PersonIso.INSTANCE,
  Codecs.StringCodec,
  Codecs.IntCodec).
  apply("fullName", "age");
```

---
# Why would I want to do this?

- Correct by construction
--

- We can reason about our code
--

- NO Annotations means NO magic


---
class: center, middle
# Verbosity

???

Java does not have some features I would like to have, so verbosity ufortunately increases.
However, since we are correct by construction, this is not as a big problem as I initially thought.
There are other languages on the JVM that will help you here, like Scala to name one.

---
class: center, middle
# Questions?

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
